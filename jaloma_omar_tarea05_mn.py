# -*- coding: utf-8 -*-
"""Jaloma_Omar_Tarea05_MN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eoGF8tiuiqMCCzBLCV1rT_hVTp78k_Iz
"""

import numpy as np

def GaussSeidel(A, b, x0=None, tol=1e-8):
    n=A.shape[0] #n será la dimensión de la matriz
    K=0 #K es el número de iteración
    err=1+tol #err es el error relativo
    x=np.empty(n) #creamos un vector de ceros
    x.fill(0)
    xold=x0
    n=n-1
    while(err>tol and K<1e8):
      for i in range(n+1):
        w=(list(A[i][:i]))+(list(A[i][i+1:]))
        z=(list(x[:i]))+(list(x[i+1:]))
        w=np.array(w)
        z=np.array(z)
        if(abs(A[i][i])<sum(abs(w))): #Aquí aseguramos que A sea diagonalmente dominante
          break
        x[i]=(1/A[i][i])*(-np.dot(w,z)+b[i]) #Aquí reside bajo como definimos los índices el método inverso
      err=(np.linalg.norm(np.subtract(x,xold))/max(1,np.linalg.norm(x))) #Aquí actualizamos el error
      xold=x
      K=K+1
    return([x,K])

def GaussSeidelTridiag(D, b, x0=None, tol=1e-8):
    n=D.shape[0] #n será la dimensión de la matriz
    K=0 #K es el número de iteración
    err=1+tol #err es el error relativo
    x=np.empty(n) #creamos un vector de ceros
    x.fill(0)
    xold=x0
    n=n-1
    while(err>tol and K<1e8):
      for i in range(n+1):
        if(abs(D[i][1])<abs(D[i][0])+abs(D[i][2])): #Aquí aseguramos que A sea diagonalmente dominante
          break
        if i==0:
           x[i]=(1/D[i][1])*(-D[i][2]*x[i+1]+b[i])
        elif i==n:
           x[i]=(1/D[i][1])*(-D[i][0]*x[i-1]+b[i])
        else:    
           x[i]=(1/D[i][1])*(-D[i][0]*x[i-1]-D[i][2]*x[i+1]+b[i]) #Aquí reside bajo como definimos los índices el método inverso
      err=(np.linalg.norm(np.subtract(x,xold))/max(1,np.linalg.norm(x))) #Aquí actualizamos el error
      xold=x
      K=K+1
    return([x,K])

N=1000

A=np.random.rand(N,N)
b=np.arange(N)
b.fill(1)
x0=np.empty(N)
x0.fill(0)


A=np.arange(N*N)
A.fill(0)
for i in range(N):
  j=0
  for j in range(N):
    if j==i-1:
      A[i*N+j]=-1
    if j==i:
      A[i*N+j]=2
    if j==i+1:
      A[i*N+j]=-1
    
A.reshape(N,N)

b=np.arange(N)
b.fill(1)
x0=np.empty(N)
x0.fill(0)

A=np.array(A).reshape((N,N))
#print(A)
S=GaussSeidel(A,b,x0) #Aquí se resuelve el sistema para A de N por N
print(S)

D=np.arange(3*N)
D.fill(0)
for i in range(N):
  j=0
  for j in range(3):
    if j==0:
      D[i*3+j]=-1
    if j==1:
      D[i*3+j]=2
    if j==2:
      D[i*3+j]=-1

D=np.array(D).reshape((N,3))
S=GaussSeidelTridiag(D,b,x0)
print(S)

import numpy as np

w=np.array([1,2,-3,4,5,6])
w=abs(w)
w=w.reshape(2,3)
print(w)
n=w.shape[0]
print(n)