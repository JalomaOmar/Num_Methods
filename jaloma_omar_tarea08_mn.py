# -*- coding: utf-8 -*-
"""Jaloma_Omar_Tarea08_MN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q4wWQIpzpxUql6su3Y9VfDqhGo3esQr4
"""

import numpy as np

def IndexMAX(A):         #Esta función regresa los índices del elemento máximo de la matriz A
  m,n=A.shape
  max=A[0][0]
  for i in range(m):
    for j in range(n):
      if A[i][j]>max:
        k=i
        l=j
        max=A[i][j]
  return(k,l)

def minusDiag(X):               #Esta función devuelve a la matriz de entrada con ceros en su diagonal
  M=X.copy()
  for i in range(X.shape[0]):
      M[i][i]=0
  return(M)


def off(X):                     #Definimos la función off basados en la norma de frobenius para una matriz, que es la que está por defecto para la función np.linalg.norm
  return(np.linalg.norm(minusDiag(X)))

def GivensR(aii,ajj,aij):
  eta=((ajj-aii)/(2*aij))
  t=((np.sign(eta))/(abs(eta)+np.sqrt(1+eta**2))) #Definimos la rotación de Givens como se sugiere
  c=(1/np.sqrt(1+t**2))
  s=t*c
  return(c,s)


def Jacobi_Alg(A, eps):
  n=A.shape[0]
  D=A.copy()               #Iniciamos a D como A, a U como la matriz identidad y a t=0
  U=np.zeros((n,n))
  for i in range(n):
    U[i][i]=1
  t=0
  while(off(D)<eps*off(A)): #Había un error en la enunciación de la tarea? Es que tuve muchos problemas porque mi programa se quedaba ciclado en el while y entonces cambié el signo de ">" a "<" y ya funcionó. ¿estaba mal enunciado en el pdf?
    i,j=IndexMAX(abs(minusDiag(D)))
    c,s=GivensR(D[i][i],D[j][j], D[i][j])  
    B=D.transpose()
    B[i]=c*D.transpose()[i]-s*D.transpose()[j]
    B[j]=c*D.transpose()[i]+s*D.transpose()[j]
    C=B.transpose()
    E=C.copy()
    E[i]=c*C[i]-s*C[j]
    E[j]=c*C[i]+s*C[j]  
    D=E.copy()
    B=U.transpose()
    B[i]=c*U.transpose()[i]-s*U.transpose()[j]
    B[j]=c*U.transpose()[i]+s*U.transpose()[j]
    U=B.transpose()
    t+=1
  return(D,U)

def RndomMat(const, n): #Esta función es para generar las matrices aleatorias de la forma que se propone
  Id=np.zeros((n,n))
  for i in range(n):
    Id[i][i]=1
  B=np.random.rand(n*n)
  B=B.reshape((n,n))
  return(np.matmul(B.transpose(), B)+const*Id)

l=list() # lista de matrices aleatorias
err1=list() # lista de errores del primer inciso
err2=list() # lista de erores del segundo inciso
eps=1e-8 #intenté poner 1e-8 PERO SE VUELVE LENTISIMO, perdón ya se que este epsilon no me sirve de mucho para aproximar a los eigenvalores
const=0.1
n=128
for i in range(30):
  l.append(RndomMat(const, n))
for i in range(30):
  D,U=Jacobi_Alg(l[i], eps)
  err1.append(np.linalg.norm(np.matmul(l[i],U) -np.matmul(U,D)))
  err2.append(np.linalg.norm(np.sort(np.diag(D)) - np.sort(np.linalg.eigvals(l[i]))))
print("Errores del primer inciso: \n")
print(err1)
print("\n-------------------------------------------------------------------------------------\n")
print("Errores del segundo inciso: \n")
print(err2)